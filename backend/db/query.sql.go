// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"
	"net/netip"
)

const chunkedCreate = `-- name: ChunkedCreate :one
INSERT INTO chunked (
  file_size, name, ip_addr, chunks_left
) VALUES (
  $1, $2, $3, $4
)
RETURNING id
`

type ChunkedCreateParams struct {
	FileSize   int64
	Name       string
	IpAddr     netip.Addr
	ChunksLeft int32
}

func (q *Queries) ChunkedCreate(ctx context.Context, arg ChunkedCreateParams) (int32, error) {
	row := q.db.QueryRow(ctx, chunkedCreate,
		arg.FileSize,
		arg.Name,
		arg.IpAddr,
		arg.ChunksLeft,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const chunkedDelete = `-- name: ChunkedDelete :exec
DELETE FROM chunked
WHERE id = $1
`

func (q *Queries) ChunkedDelete(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, chunkedDelete, id)
	return err
}

const chunkedLeftDecrement = `-- name: ChunkedLeftDecrement :one
UPDATE chunked
SET chunks_left = GREATEST(0, chunks_left - 1)
WHERE id = $1
RETURNING chunks_left
`

func (q *Queries) ChunkedLeftDecrement(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, chunkedLeftDecrement, id)
	var chunks_left int32
	err := row.Scan(&chunks_left)
	return chunks_left, err
}

const fileCreate = `-- name: FileCreate :one
INSERT INTO files (
  mime_type, file_size, name, ip_addr, hash
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id
`

type FileCreateParams struct {
	MimeType string
	FileSize int64
	Name     string
	IpAddr   netip.Addr
	Hash     string
}

func (q *Queries) FileCreate(ctx context.Context, arg FileCreateParams) (int32, error) {
	row := q.db.QueryRow(ctx, fileCreate,
		arg.MimeType,
		arg.FileSize,
		arg.Name,
		arg.IpAddr,
		arg.Hash,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const fileDelete = `-- name: FileDelete :exec
DELETE FROM files
WHERE id = $1
`

func (q *Queries) FileDelete(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, fileDelete, id)
	return err
}

const fileFromHash = `-- name: FileFromHash :one
SELECT id, mime_type FROM files
WHERE hash = $1
`

type FileFromHashRow struct {
	ID       int32
	MimeType string
}

func (q *Queries) FileFromHash(ctx context.Context, hash string) (FileFromHashRow, error) {
	row := q.db.QueryRow(ctx, fileFromHash, hash)
	var i FileFromHashRow
	err := row.Scan(&i.ID, &i.MimeType)
	return i, err
}
