// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const chunkedCreate = `-- name: ChunkedCreate :one
INSERT INTO chunked (
  file_size, name, ip_addr, chunks_left, chunks_total, user_agent
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id
`

type ChunkedCreateParams struct {
	FileSize    int64
	Name        string
	IpAddr      netip.Addr
	ChunksLeft  int32
	ChunksTotal int32
	UserAgent   int64
}

func (q *Queries) ChunkedCreate(ctx context.Context, arg ChunkedCreateParams) (int32, error) {
	row := q.db.QueryRow(ctx, chunkedCreate,
		arg.FileSize,
		arg.Name,
		arg.IpAddr,
		arg.ChunksLeft,
		arg.ChunksTotal,
		arg.UserAgent,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const chunkedDelete = `-- name: ChunkedDelete :exec
DELETE FROM chunked
WHERE id = $1
`

func (q *Queries) ChunkedDelete(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, chunkedDelete, id)
	return err
}

const chunkedFromId = `-- name: ChunkedFromId :one
SELECT file_size, chunks_total, created_at, last_access FROM chunked
WHERE id = $1
`

type ChunkedFromIdRow struct {
	FileSize    int64
	ChunksTotal int32
	CreatedAt   pgtype.Timestamp
	LastAccess  pgtype.Timestamp
}

func (q *Queries) ChunkedFromId(ctx context.Context, id int32) (ChunkedFromIdRow, error) {
	row := q.db.QueryRow(ctx, chunkedFromId, id)
	var i ChunkedFromIdRow
	err := row.Scan(
		&i.FileSize,
		&i.ChunksTotal,
		&i.CreatedAt,
		&i.LastAccess,
	)
	return i, err
}

const chunkedLeftDecrement = `-- name: ChunkedLeftDecrement :one
UPDATE chunked
SET chunks_left = GREATEST(0, chunks_left - 1), last_access = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING chunks_left
`

func (q *Queries) ChunkedLeftDecrement(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, chunkedLeftDecrement, id)
	var chunks_left int32
	err := row.Scan(&chunks_left)
	return chunks_left, err
}

const fileCreate = `-- name: FileCreate :one
INSERT INTO files (
  mime_type, file_size, hash
) VALUES (
  $1, $2, $3
)
RETURNING id
`

type FileCreateParams struct {
	MimeType string
	FileSize int64
	Hash     string
}

func (q *Queries) FileCreate(ctx context.Context, arg FileCreateParams) (int32, error) {
	row := q.db.QueryRow(ctx, fileCreate, arg.MimeType, arg.FileSize, arg.Hash)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const fileFromChunked = `-- name: FileFromChunked :one
INSERT INTO files (mime_type, file_size, hash)
SELECT $2, chunked.file_size, $3 
FROM chunked
WHERE chunked.id = $1
RETURNING files.id
`

type FileFromChunkedParams struct {
	ID       int32
	MimeType string
	Hash     string
}

func (q *Queries) FileFromChunked(ctx context.Context, arg FileFromChunkedParams) (int32, error) {
	row := q.db.QueryRow(ctx, fileFromChunked, arg.ID, arg.MimeType, arg.Hash)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const fileFromHash = `-- name: FileFromHash :one
SELECT id, mime_type FROM files
WHERE hash = $1
`

type FileFromHashRow struct {
	ID       int32
	MimeType string
}

func (q *Queries) FileFromHash(ctx context.Context, hash string) (FileFromHashRow, error) {
	row := q.db.QueryRow(ctx, fileFromHash, hash)
	var i FileFromHashRow
	err := row.Scan(&i.ID, &i.MimeType)
	return i, err
}

const fileFromId = `-- name: FileFromId :one
SELECT mime_type, file_size FROM files
WHERE id = $1
`

type FileFromIdRow struct {
	MimeType string
	FileSize int64
}

func (q *Queries) FileFromId(ctx context.Context, id int32) (FileFromIdRow, error) {
	row := q.db.QueryRow(ctx, fileFromId, id)
	var i FileFromIdRow
	err := row.Scan(&i.MimeType, &i.FileSize)
	return i, err
}

const uploadCreate = `-- name: UploadCreate :one
INSERT INTO uploads (
  ip_addr, user_agent, file, name
) VALUES (
  $1, $2, $3, $4
)
RETURNING id
`

type UploadCreateParams struct {
	IpAddr    netip.Addr
	UserAgent int64
	File      int64
	Name      string
}

func (q *Queries) UploadCreate(ctx context.Context, arg UploadCreateParams) (int64, error) {
	row := q.db.QueryRow(ctx, uploadCreate,
		arg.IpAddr,
		arg.UserAgent,
		arg.File,
		arg.Name,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const uploadFromChunked = `-- name: UploadFromChunked :exec
INSERT INTO uploads (ip_addr, user_agent, file, name)
SELECT chunked.ip_addr, chunked.user_agent, $2, chunked.name 
FROM chunked
WHERE chunked.id = $1
`

type UploadFromChunkedParams struct {
	ID   int32
	File int64
}

func (q *Queries) UploadFromChunked(ctx context.Context, arg UploadFromChunkedParams) error {
	_, err := q.db.Exec(ctx, uploadFromChunked, arg.ID, arg.File)
	return err
}

const userAgentIdGet = `-- name: UserAgentIdGet :one
WITH res AS (
    INSERT INTO user_agents (user_agent)
    VALUES ($1)
    ON CONFLICT (user_agent) DO NOTHING
    RETURNING id
)
SELECT id
FROM res
UNION
SELECT id
FROM user_agents
WHERE user_agent = $1
LIMIT 1
`

func (q *Queries) UserAgentIdGet(ctx context.Context, userAgent string) (int64, error) {
	row := q.db.QueryRow(ctx, userAgentIdGet, userAgent)
	var id int64
	err := row.Scan(&id)
	return id, err
}
